# Word Pattern ‚Äî Java Solution 
---

## üß© Problem Description

Given a pattern string and a space-separated string `s`, determine whether `s` follows the same pattern.

A valid match means:
- Each character in `pattern` maps to exactly one word.
- Each word maps back to exactly one character.  
This is a **bijective mapping**.

### Example
```
pattern = "abba"
s = "dog cat cat dog"

Output: true
```

---

## üí° Approach

1. Split the string `s` into words.  
2. If the number of words does not match the length of the pattern ‚Üí return false.  
3. Use two hash maps to enforce a bijection:
   - `mapP`: char ‚Üí word  
   - `mapT`: word ‚Üí char  
4. For each index:
   - Check if existing mappings match.  
   - If no mapping exists, create one.  
5. If any mismatch occurs ‚Üí return false.

---

## ‚è±Ô∏è Time & Space Complexity

| Complexity | Value |
|-----------|--------|
| **Time**  | O(n), where n = number of words |
| **Space** | O(n), for the two hash maps |

---

## ‚úÖ Java Implementation

```java
import java.util.HashMap;

class Solution {
    public boolean wordPattern(String pattern, String s) {
        String[] p = s.split(" ");
        if (pattern.length() != p.length)
            return false;

        HashMap<Character, String> mapP = new HashMap<>();
        HashMap<String, Character> mapT = new HashMap<>();

        for (int i = 0; i < p.length; i++) {
            char c = pattern.charAt(i);
            String word = p[i];

            // pattern ‚Üí word mapping
            if (mapP.containsKey(c)) {
                if (!mapP.get(c).equals(word))
                    return false;
            } else {
                mapP.put(c, word);
            }

            // word ‚Üí pattern mapping
            if (mapT.containsKey(word)) {
                if (mapT.get(word) != c)
                    return false;
            } else {
                mapT.put(word, c);
            }
        }
        return true;
    }
}
