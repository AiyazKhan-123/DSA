# ðŸ” Reverse Integer

## ðŸ“ Problem Statement
Given a signed 32-bit integer `x`, return its digits reversed.

If reversing `x` causes the value to go **outside** the signed 32-bit integer range:  
`[-2^31, 2^31 - 1]`  
return **0**.

---

## ðŸ“Œ Examples

### Example 1
**Input:**  
x = 123  
**Output:**  
321

### Example 2
**Input:**  
x = -123  
**Output:**  
-321

### Example 3
**Input:**  
x = 1534236469  
**Output:**  
0  
(Because reversed integer overflows)

---

## ðŸ’¡ Approach

1. Extract digits using `% 10`  
2. Build the reversed number: `r = r * 10 + lastDigit`  
3. Before every update, check for overflow:  
   - If `r > INT_MAX/10` or equal and `last > 7` â†’ overflow  
   - If `r < INT_MIN/10` or equal and `last < -8` â†’ underflow  
4. Return 0 if overflow occurs.

---

## â± Time Complexity
**O(logâ‚â‚€(N))**  
Because we process each digit once.

## ðŸ’¾ Space Complexity
**O(1)**  

---

## ðŸ§‘â€ðŸ’» Java Code

```java
class Solution {
    public int reverse(int x) {
        int r = 0;

        while (x != 0) {
            int last = x % 10;

            // Check for overflow (positive)
            if (r > Integer.MAX_VALUE / 10 || 
               (r == Integer.MAX_VALUE / 10 && last > 7)) {
                return 0;
            }

            // Check for underflow (negative)
            if (r < Integer.MIN_VALUE / 10 || 
               (r == Integer.MIN_VALUE / 10 && last < -8)) {
                return 0;
            }

            r = (r * 10) + last; // build reversed number
            x = x / 10; // remove last digit
        }

        return r;
    }
}
